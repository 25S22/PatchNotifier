def run_cve_search(self, cve_ids, use_qid_lookup=True):
        """
        Main: login, then either QID-based search or direct CVE search (fallback or per user choice),
        generate Excel, send email, logout.
        use_qid_lookup: if True, attempt get_qid_from_cve + search_vulnerable_hosts; if that fails or empty, fallback to direct CVE search.
        """
        if not cve_ids:
            logger.error("No CVE IDs provided.")
            return

        self.login()
        try:
            results = []
            if use_qid_lookup:
                # Attempt QID-based search
                all_qids = []
                cve_to_qid_mapping = {}
                for cve in cve_ids:
                    try:
                        qid_info = self.get_qid_from_cve(cve)
                    except Exception as e:
                        logger.warning(f"QID lookup failed for {cve}: {e}")
                        qid_info = []
                    if qid_info:
                        qids_for_cve = [info["qid"] for info in qid_info]
                        all_qids.extend(qids_for_cve)
                        cve_to_qid_mapping[cve] = qids_for_cve
                    else:
                        logger.warning(f"No QIDs found for CVE {cve}, skipping in QID-based step.")
                if all_qids:
                    # Perform hostinstancevuln search
                    try:
                        vuln_instances = self.search_vulnerable_hosts(all_qids)
                        logger.info(f"Found {len(vuln_instances)} vulnerability instances via QID-based search.")
                        results = self.extract_vulnerability_details(vuln_instances)
                    except Exception as e:
                        logger.error(f"Error during QID-based host search: {e}")
                        results = []
                else:
                    logger.info("No QIDs found for any CVE; skipping QID-based search.")
            # If no results from QID-based or use_qid_lookup=False, fallback to direct CVE search
            if not results:
                logger.info("Performing direct CVE search via Host List Detection API...")
                results = self.get_host_list_detection(cve_ids)
                logger.info(f"Direct CVE search returned {len(results)} entries.")

            # If still no results, create empty report
            if not results:
                logger.info("No vulnerable hosts found. Creating empty report.")
                columns = [
                    "Host ID", "Host Instance ID", "DNS Name", "NetBIOS Name", "Operating System",
                    "CVE", "QID", "Severity", "Status", "Port", "Protocol",
                    "First Found", "Last Found", "Last Vulnerability Scan", "Detection Results"
                ]
                df_empty = pd.DataFrame(columns=columns)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                fname = f"CVE_Vulnerability_Report_{'_'.join([c.replace('CVE-', '') for c in cve_ids])}_{timestamp}.xlsx"
                df_empty.to_excel(fname, index=False)
                logger.info(f"Empty Excel file created: {fname}")
                return

            # Build DataFrame
            df = pd.DataFrame(results)
            # Sort by severity if present
            if "Severity" in df.columns:
                severity_order = ["5", "4", "3", "2", "1"]
                df["Severity_Sort"] = pd.Categorical(df["Severity"], categories=severity_order, ordered=True)
                sort_cols = ["Severity_Sort"]
                if "Host ID" in df.columns:
                    sort_cols.append("Host ID")
                if "CVE" in df.columns:
                    sort_cols.append("CVE")
                df = df.sort_values(by=sort_cols)
                df = df.drop(columns=["Severity_Sort"], errors="ignore")

            # Save to Excel
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            fname = f"CVE_Vulnerability_Report_{'_'.join([c.replace('CVE-', '') for c in cve_ids])}_{timestamp}.xlsx"
            with pd.ExcelWriter(fname, engine="openpyxl") as writer:
                df.to_excel(writer, sheet_name="Vulnerability Details", index=False)
                # Summary
                unique_hosts = df["Host ID"].nunique() if "Host ID" in df.columns else 0
                total_instances = len(df)
                summary_data = {
                    "Metric": [
                        "Total CVEs Searched",
                        "Total Vulnerability Instances",
                        "Total Vulnerable Hosts",
                        "Critical Severity (5)",
                        "High Severity (4)",
                        "Medium Severity (3)",
                        "Low Severity (2)",
                        "Info Severity (1)",
                        "Search Date"
                    ],
                    "Value": [
                        len(cve_ids),
                        total_instances,
                        unique_hosts,
                        int(df[df["Severity"] == "5"].shape[0]) if "Severity" in df.columns else 0,
                        int(df[df["Severity"] == "4"].shape[0]) if "Severity" in df.columns else 0,
                        int(df[df["Severity"] == "3"].shape[0]) if "Severity" in df.columns else 0,
                        int(df[df["Severity"] == "2"].shape[0]) if "Severity" in df.columns else 0,
                        int(df[df["Severity"] == "1"].shape[0]) if "Severity" in df.columns else 0,
                        datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    ]
                }
                summary_df = pd.DataFrame(summary_data)
                summary_df.to_excel(writer, sheet_name="Summary", index=False)
                # CVE to QID mapping sheet (if QID-based did yield something)
                mapping = []
                if use_qid_lookup:
                    for row in results:
                        cve = row.get("CVE", "")
                        qid = row.get("QID", "")
                        if cve and qid:
                            mapping.append({"CVE": cve, "QID": qid})
                if mapping:
                    mapping_df = pd.DataFrame(mapping).drop_duplicates()
                    mapping_df.to_excel(writer, sheet_name="CVE to QID Mapping", index=False)
                # CVE List sheet
                cve_list_df = pd.DataFrame({"CVE": cve_ids})
                cve_list_df.to_excel(writer, sheet_name="CVE List", index=False)
            logger.info(f"Saved Excel report: {fname}")

            # Send email draft if any vulnerabilities
            unique_hosts = df["Host ID"].nunique() if "Host ID" in df.columns else 0
            self.send_email(fname, cve_ids, unique_hosts, len(df))

        finally:
            try:
                self.logout()
            except Exception as e:
                logger.warning(f"Error during logout: {e}")


def prompt_non_empty(prompt_text, default=None, is_password=False):
    """
    Prompt user until a non-empty response (or default if provided).
    """
    while True:
        if default is not None:
            if is_password:
                # do not print default password
                return default
            else:
                print(f"{prompt_text} [Using default: {default}]")
                return default
        if is_password:
            val = getpass.getpass(prompt_text + ": ")
        else:
            val = input(prompt_text + ": ").strip()
        if val:
            return val
        print("Input cannot be empty.")


def main():
    """
    Main entry: uses DEFAULT_* if provided, otherwise prompts for:
    - Qualys API Base URL
    - Username
    - Password
    - Cert path (or skip)
    - Page size
    - Log level (if not defaulted)
    - CVE IDs
    - Whether to attempt QID-based lookup first
    Then runs the search.
    """
    print("=== Qualys CVE Vulnerability Searcher ===")

    # 1. Base URL
    if DEFAULT_BASE_URL:
        base_url = DEFAULT_BASE_URL
        print(f"Using default Base URL: {base_url}")
    else:
        base_url = input("Enter Qualys API Base URL (e.g., https://qualysapi.qg1.apps.qualys.in): ").strip()
        while not base_url:
            print("Base URL is required.")
            base_url = input("Enter Qualys API Base URL: ").strip()

    # 2. Username
    username = prompt_non_empty("Enter Qualys username", default=DEFAULT_USERNAME)

    # 3. Password
    password = prompt_non_empty("Enter Qualys password", default=DEFAULT_PASSWORD, is_password=True)

    # 4. Cert path or skip
    if DEFAULT_CERT_PATH is not None:
        cert_path = DEFAULT_CERT_PATH
        if cert_path:
            print(f"Using default certificate path: {cert_path}")
        else:
            print("Default: SSL verification is skipped (verify=False).")
    else:
        cert_input = input("Enter path to corporate cert PEM (leave blank to skip SSL verification): ").strip()
        if cert_input:
            cert_path = cert_input
        else:
            cert_path = False
            print("SSL verification will be skipped (verify=False).")

    # 5. Page size
    if DEFAULT_PAGE_SIZE:
        page_size = DEFAULT_PAGE_SIZE
        print(f"Using default page size: {page_size}")
    else:
        while True:
            ps = input("Enter page size (number of results per page for QID-based search, e.g., 100): ").strip()
            if not ps:
                print("Page size is required.")
                continue
            try:
                page_size = int(ps)
                if page_size <= 0:
                    raise ValueError
                break
            except ValueError:
                print("Please enter a positive integer for page size.")
        print(f"Using page size: {page_size}")

    # 6. Log level (optional override)
    if not DEFAULT_LOG_LEVEL:
        lvl = input("Enter log level [DEBUG, INFO, WARNING, ERROR] (leave blank for INFO): ").strip().upper()
        if lvl in ("DEBUG", "INFO", "WARNING", "ERROR"):
            logger.setLevel(getattr(logging, lvl))
            print(f"Log level set to: {lvl}")
        else:
            logger.setLevel(logging.INFO)
            print("Log level set to INFO")
    else:
        print(f"Log level set to default: {DEFAULT_LOG_LEVEL}")

    # 7. CVE IDs input
    while True:
        cve_input = input("Enter CVE ID(s), separated by commas or spaces (e.g., CVE-2024-1234, CVE-2024-5678): ").strip()
        if not cve_input:
            print("Please enter at least one CVE ID.")
            continue
        cve_input_clean = cve_input.replace(",", " ")
        cve_list = [c.strip().upper() for c in cve_input_clean.split() if c.strip()]
        if not cve_list:
            print("No valid CVE IDs found. Try again.")
            continue
        invalids = [c for c in cve_list if not c.startswith("CVE-")]
        if invalids:
            print(f"Warning: these entries do not look like CVE IDs: {invalids}")
            yn = input("Proceed anyway? (y/N): ").strip().lower()
            if yn != "y":
                continue
        break
    logger.info(f"Will search for CVE(s): {cve_list}")

    # 8. Ask if QID-based lookup should be attempted first
    yn = input("Attempt QID→host search first? (y/N): ").strip().lower()
    use_qid_lookup = (yn == "y")
    if use_qid_lookup:
        logger.info("Will attempt QID-based lookup first, then fallback to direct CVE search if needed.")
    else:
        logger.info("Will perform direct CVE search only (Host List Detection API).")

    # Instantiate and run
    try:
        searcher = QualysCVESearcher(
            username=username,
            password=password,
            cert_path=cert_path,
            base_url=base_url,
            page_size=page_size
        )
        searcher.run_cve_search(cve_list, use_qid_lookup=use_qid_lookup)
    except Exception as e:
        logger.error(f"Exception during CVE search: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
