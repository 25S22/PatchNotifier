import requests
import xml.etree.ElementTree as ET
from requests.auth import HTTPBasicAuth
import pandas as pd
from packaging import version
import logging
import sys
import os
import win32com.client as win32

# === CONFIGURATION ===
USERNAME = "your_qualys_username"
PASSWORD = "your_qualys_password"
CERT_PATH = "/path/to/your/corporate_cert.pem"
BASE_URL = "https://qualysapi.qg1.apps.qualys.in"
PAGE_SIZE = 100
FILTER_OPERATOR = "CONTAINS"
LOG_LEVEL = logging.INFO

# === LOGGER SETUP ===
logger = logging.getLogger("QualysFilteredSearch")
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("[%(levelname)s] %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(LOG_LEVEL)

class QualysSearcher:
    def __init__(self, username, password, cert_path, page_size=100):
        self.base_url = BASE_URL.rstrip("/")
        self.session = requests.Session()
        self.auth = HTTPBasicAuth(username, password)
        self.cert_path = cert_path
        self.page_size = page_size
        self.fo_headers = {"X-Requested-With": "Python script"}
        self.qps_headers = {
            "Content-Type": "application/xml",
            "Accept": "application/xml"
        }

    def login(self):
        url = f"{self.base_url}/api/2.0/fo/session/"
        data = {
            "action": "login",
            "username": self.auth.username,
            "password": self.auth.password
        }
        logger.info("Logging in...")
        resp = self.session.post(url, headers=self.fo_headers, data=data, verify=self.cert_path)
        resp.raise_for_status()
        if "QualysSession" not in self.session.cookies:
            raise Exception("Login failed.")
        logger.info("Login successful.")

    def logout(self):
        url = f"{self.base_url}/api/2.0/fo/session/"
        data = {"action": "logout"}
        self.session.post(url, headers=self.fo_headers, data=data, verify=self.cert_path)
        logger.info("Logged out.")

    def build_request(self, software_name, offset):
        root = ET.Element("ServiceRequest")
        filters = ET.SubElement(root, "filters")
        ET.SubElement(filters, "Criteria", field="installedSoftware", operator=FILTER_OPERATOR).text = software_name
        prefs = ET.SubElement(root, "preferences")
        ET.SubElement(prefs, "startFromOffset").text = str(offset)
        ET.SubElement(prefs, "limitResults").text = str(self.page_size)
        fields = ET.SubElement(root, "fields")
        host = ET.SubElement(fields, "HostAsset")
        ET.SubElement(host, "id")
        ET.SubElement(host, "dnsHostName")
        ET.SubElement(host, "netbiosName")
        swlist = ET.SubElement(host, "HostAssetSoftwareList")
        sw = ET.SubElement(swlist, "HostAssetSoftware")
        ET.SubElement(sw, "name")
        ET.SubElement(sw, "version")
        return ET.tostring(root, encoding="utf-8")

    def search_hosts(self, software_name):
        url = f"{self.base_url}/qps/rest/2.0/search/am/hostasset"
        offset, page = 1, 1
        results = []

        while True:
            logger.info(f"Fetching page {page}, offset {offset}...")
            body = self.build_request(software_name, offset)
            resp = self.session.post(url, headers=self.qps_headers, auth=self.auth, data=body, verify=self.cert_path)
            if resp.status_code == 403:
                raise Exception("Forbidden. Check access/credentials.")
            resp.raise_for_status()

            try:
                root = ET.fromstring(resp.content)
            except ET.ParseError:
                raise Exception("Malformed XML response.")

            assets = root.findall(".//HostAsset")
            if not assets:
                break

            results.extend(assets)
            has_more = root.findtext(".//hasMoreRecords") == "true"
            if not has_more:
                break
            offset += self.page_size
            page += 1

        return results

    def extract_below_version(self, host, software_name, max_version):
        matches = []
        host_id = host.findtext("id", "")
        dns = host.findtext("dnsHostName", "")
        netbios = host.findtext("netbiosName", "")
        found = False

        for sw in host.findall(".//HostAssetSoftware"):
            name = (sw.findtext("name") or "").strip()
            ver = (sw.findtext("version") or "").strip()

            if name.lower() == software_name.lower():
                found = True
                try:
                    if version.parse(ver) < version.parse(max_version):
                        matches.append({
                            "Host ID": host_id,
                            "DNS": dns,
                            "NetBIOS": netbios,
                            "Software": name,
                            "Version": ver,
                            "Status": "Below target"
                        })
                    else:
                        matches.append({
                            "Host ID": host_id,
                            "DNS": dns,
                            "NetBIOS": netbios,
                            "Software": name,
                            "Version": ver,
                            "Status": "Up-to-date"
                        })
                except Exception as e:
                    logger.warning(f"Invalid version format: {ver} on host {host_id}")
                    matches.append({
                        "Host ID": host_id,
                        "DNS": dns,
                        "NetBIOS": netbios,
                        "Software": name,
                        "Version": ver,
                        "Status": "Unparsed"
                    })

        if not found:
            matches.append({
                "Host ID": host_id,
                "DNS": dns,
                "NetBIOS": netbios,
                "Software": software_name,
                "Version": "",
                "Status": "Not Found"
            })

        return matches

    def send_email(self, filename, software_name, max_version):
        outlook = win32.Dispatch("Outlook.Application")
        mail = outlook.CreateItem(0)
        mail.Subject = f"[PATCH ALERT] Devices with {software_name} below version {max_version}"
        mail.Body = f"""
Hello,

Please find attached the list of devices where '{software_name}' is installed with versions below the required '{max_version}'.

Take appropriate patching action.

Regards,
Patch Automation System
        """.strip()
        mail.Attachments.Add(os.path.abspath(filename))
        mail.Display()  # Opens the draft

    def run(self, software_name, max_version):
        self.login()
        try:
            hosts = self.search_hosts(software_name)
            logger.info(f"Found {len(hosts)} hosts.")
            all_matches = []
            for i, host in enumerate(hosts, 1):
                matches = self.extract_below_version(host, software_name, max_version)
                all_matches.extend(matches)
                if i % 100 == 0:
                    logger.info(f"Processed {i}/{len(hosts)} hosts")

            df = pd.DataFrame(all_matches)
            filename = f"{software_name.replace(' ', '_')}_below_{max_version}.xlsx"
            df.to_excel(filename, index=False)
            logger.info(f"Saved Excel: {filename}")
            self.send_email(filename, software_name, max_version)

        finally:
            self.logout()


def main():
    software = input("Enter software name (case-insensitive exact match): ").strip()
    max_ver = input("Enter max allowed version (e.g., 117.0.0): ").strip()
    if not software or not max_ver:
        print("Missing software/version input.")
        sys.exit(1)

    qs = QualysSearcher(USERNAME, PASSWORD, CERT_PATH, page_size=PAGE_SIZE)
    qs.run(software, max_ver)


if __name__ == "__main__":
    main()
