import requests
import xml.etree.ElementTree as ET
from requests.auth import HTTPBasicAuth
import pandas as pd
import sys
import logging

# === CONFIGURATION ===
USERNAME = "your_qualys_username"  # <-- replace
PASSWORD = "your_qualys_password"  # <-- replace
CERT_PATH = "/path/to/your/corporate_cert.pem"  # <-- replace
BASE_URL = "https://qualysapi.qg1.apps.qualys.in"
PAGE_SIZE = 100
FILTER_OPERATOR = "CONTAINS"
LOG_LEVEL = logging.INFO

# === LOGGER SETUP ===
logger = logging.getLogger("QualysHostSoftwareFetcher")
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("[%(levelname)s] %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(LOG_LEVEL)


class QualysSoftwareFetcher:
    def __init__(self, username, password, cert_path, page_size=100):
        self.base_url = BASE_URL.rstrip("/")
        self.session = requests.Session()
        self.auth = HTTPBasicAuth(username, password)
        self.cert_path = cert_path
        self.page_size = page_size
        self.fo_headers = {"X-Requested-With": "Python script"}
        self.qps_headers = {
            "Content-Type": "application/xml",
            "Accept": "application/xml"
        }

    def login(self):
        login_url = f"{self.base_url}/api/2.0/fo/session/"
        data = {
            "action": "login",
            "username": self.auth.username,
            "password": self.auth.password
        }
        logger.info("Logging in...")
        resp = self.session.post(login_url, headers=self.fo_headers, data=data, verify=self.cert_path)
        resp.raise_for_status()
        if "QualysSession" not in self.session.cookies:
            raise Exception("Login failed: missing session cookie.")
        logger.info("Login successful.")

    def logout(self):
        logout_url = f"{self.base_url}/api/2.0/fo/session/"
        data = {"action": "logout"}
        try:
            self.session.post(logout_url, headers=self.fo_headers, data=data, verify=self.cert_path)
            logger.info("Logout successful.")
        except:
            logger.warning("Logout failed or already logged out.")

    def build_search_body(self, software_name: str, offset: int) -> bytes:
        root = ET.Element("ServiceRequest")
        filters = ET.SubElement(root, "filters")
        criteria = ET.SubElement(filters, "Criteria", field="installedSoftware", operator=FILTER_OPERATOR)
        criteria.text = software_name

        prefs = ET.SubElement(root, "preferences")
        ET.SubElement(prefs, "startFromOffset").text = str(offset)
        ET.SubElement(prefs, "limitResults").text = str(self.page_size)

        fields = ET.SubElement(root, "fields")
        ha = ET.SubElement(fields, "HostAsset")
        ET.SubElement(ha, "id")
        ET.SubElement(ha, "dnsHostName")
        ET.SubElement(ha, "netbiosName")
        hasl = ET.SubElement(ha, "HostAssetSoftwareList")
        has = ET.SubElement(hasl, "HostAssetSoftware")
        ET.SubElement(has, "name")
        ET.SubElement(has, "version")

        return ET.tostring(root, encoding="utf-8", method="xml")

    def search_all_hosts(self, software_name: str):
        endpoint = f"{self.base_url}/qps/rest/2.0/search/am/hostasset"
        results = []
        offset = 1
        page = 1

        while True:
            logger.info(f"Fetching page {page} with offset {offset}...")
            body = self.build_search_body(software_name, offset)
            resp = self.session.post(endpoint, headers=self.qps_headers, auth=self.auth,
                                     data=body, verify=self.cert_path)
            if resp.status_code == 403:
                logger.error("Forbidden: Check access and permissions.")
                raise Exception("403 Forbidden")
            resp.raise_for_status()

            root = ET.fromstring(resp.content)
            if root.findtext("responseCode") != "SUCCESS":
                logger.error("API call failed.")
                raise Exception("Search failed")

            hosts = root.findall(".//HostAsset")
            if not hosts:
                logger.info("No more hosts found.")
                break

            for host in hosts:
                host_id = host.findtext("id", default="")
                dns = host.findtext("dnsHostName", default="")
                netbios = host.findtext("netbiosName", default="")

                matched = False
                for sw in host.findall(".//HostAssetSoftware"):
                    name = (sw.findtext("name") or "").strip()
                    version = (sw.findtext("version") or "").strip()

                    if name.lower() == software_name.lower():
                        results.append({
                            "id": host_id,
                            "dnsHostName": dns,
                            "netbiosName": netbios,
                            "software": name,
                            "version": version or "NOT FOUND"
                        })
                        matched = True
                        break

                if not matched:
                    results.append({
                        "id": host_id,
                        "dnsHostName": dns,
                        "netbiosName": netbios,
                        "software": software_name,
                        "version": "NOT FOUND"
                    })

            has_more = root.findtext(".//hasMoreRecords") == "true"
            if not has_more:
                break

            offset += self.page_size
            page += 1

        return results

    def run(self, software_name: str):
        try:
            self.login()
            rows = self.search_all_hosts(software_name)
        finally:
            self.logout()

        if rows:
            df = pd.DataFrame(rows)
            filename = f"{software_name.replace(' ', '_')}_results.xlsx"
            df.to_excel(filename, index=False)
            logger.info(f"Excel saved: {filename} with {len(rows)} rows.")
        else:
            logger.warning("No matching hosts found.")


def main():
    software_name = input("Enter software name to search (exact match): ").strip()
    if not software_name:
        logger.error("Software name required. Exiting.")
        sys.exit(1)

    searcher = QualysSoftwareFetcher(USERNAME, PASSWORD, CERT_PATH, page_size=PAGE_SIZE)
    searcher.run(software_name)


if __name__ == "__main__":
    main()
