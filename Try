import requests
import xml.etree.ElementTree as ET
from requests.auth import HTTPBasicAuth
import csv
import sys

class QualysHostAssetSearcher:
    """
    Search Host Assets in Qualys that have a given installed software,
    using QPS REST 2.0 API with proper pagination and detail retrieval.
    """

    def __init__(self, username: str, password: str, cert_path: str, page_size: int = 100):
        # Base URL for QG1 (India)
        self.base_url = "https://qualysapi.qg1.apps.qualys.in"
        self.session = requests.Session()
        self.auth = HTTPBasicAuth(username, password)
        self.cert_path = cert_path
        self.page_size = page_size
        # FO session headers
        self.fo_headers = {"X-Requested-With": "Python script"}
        # QPS REST headers
        self.qps_headers = {
            "Content-Type": "application/xml",
            "Accept": "application/xml"
        }

    def login(self):
        """
        FO session login: POST to /api/2.0/fo/session/ with action=login.
        """
        url = f"{self.base_url}/api/2.0/fo/session/"
        data = {"action": "login", "username": self.auth.username, "password": self.auth.password}
        resp = self.session.post(url, headers=self.fo_headers, data=data, verify=self.cert_path)
        try:
            resp.raise_for_status()
        except Exception as e:
            raise Exception(f"Login HTTP error: {e}\nResponse:\n{resp.text}")
        # Confirm QualysSession cookie
        if "QualysSession" not in self.session.cookies:
            print(f"[DEBUG] Cookies after login: {self.session.cookies.get_dict()}")
            raise Exception("Login failed: QualysSession cookie not set. Check credentials/SSL cert.")
        print("[✓] Logged in to FO session.")

    def logout(self):
        """
        FO session logout: POST to /api/2.0/fo/session/ with action=logout.
        """
        url = f"{self.base_url}/api/2.0/fo/session/"
        data = {"action": "logout"}
        try:
            resp = self.session.post(url, headers=self.fo_headers, data=data, verify=self.cert_path)
            resp.raise_for_status()
        except Exception as e:
            print(f"[!] Logout HTTP error (ignored): {e}")
        else:
            print("[✓] Logged out from FO session.")

    def build_search_body(self, software_name: str, start_offset: int) -> bytes:
        """
        Build XML body for search Host Assets:
        <ServiceRequest>
          <filters>
            <Criteria field="installedSoftware" operator="CONTAINS">software_name</Criteria>
          </filters>
          <preferences>
            <startFromOffset>start_offset</startFromOffset>
            <limitResults>page_size</limitResults>
          </preferences>
        </ServiceRequest>
        """
        root = ET.Element("ServiceRequest")
        filters = ET.SubElement(root, "filters")
        # Use CONTAINS to match substring; adjust to EQUALS if exact
        criteria = ET.SubElement(filters, "Criteria", field="installedSoftware", operator="CONTAINS")
        criteria.text = software_name

        prefs = ET.SubElement(root, "preferences")
        ET.SubElement(prefs, "startFromOffset").text = str(start_offset)
        ET.SubElement(prefs, "limitResults").text = str(self.page_size)

        return ET.tostring(root, encoding="utf-8", method="xml")

    def search_host_assets(self, software_name: str):
        """
        Search all HostAsset entries matching installedSoftware CONTAINS software_name.
        Paginate until hasMoreRecords is false.
        Returns list of HostAsset XML elements.
        """
        search_url = f"{self.base_url}/qps/rest/2.0/search/am/hostasset"
        all_host_elements = []
        offset = 1  # 1-based
        page = 1
        print(f"[*] Starting Host Asset search for installedSoftware containing: '{software_name}'")
        while True:
            print(f"  → Page {page}, startFromOffset={offset}")
            body = self.build_search_body(software_name, offset)
            resp = self.session.post(
                search_url,
                headers=self.qps_headers,
                auth=self.auth,
                data=body,
                verify=self.cert_path
            )
            if resp.status_code == 403:
                raise Exception(f"Search returned 403 Forbidden. Check Basic Auth or session. Response:\n{resp.text}")
            try:
                resp.raise_for_status()
            except Exception as e:
                raise Exception(f"Search HTTP error: {e}\nResponse:\n{resp.text}")

            # Parse XML
            try:
                root = ET.fromstring(resp.content)
            except ET.ParseError as e:
                raise Exception(f"Failed parsing search response XML: {e}\nContent:\n{resp.text}")

            # Check responseCode
            resp_code = root.findtext("responseCode")
            if resp_code != "SUCCESS":
                raise Exception(f"Search responseCode={resp_code}. Full response:\n{resp.text}")

            # Extract HostAsset elements
            host_elements = root.findall(".//HostAsset")
            count_page = len(host_elements)
            print(f"    • Retrieved {count_page} HostAsset entries on page {page}")
            if count_page == 0:
                break
            all_host_elements.extend(host_elements)

            # Pagination: hasMoreRecords?
            has_more = root.findtext(".//hasMoreRecords") == "true"
            if not has_more:
                break
            # Next offset: increment by page_size
            offset += self.page_size
            page += 1

        total = len(all_host_elements)
        print(f"[✓] Search complete. Total HostAsset entries found: {total}")
        return all_host_elements

    def get_software_for_host(self, host_id: str, dns: str, netbios: str, software_name: str):
        """
        Retrieve detailed software list for a HostAsset ID, return list of dicts matching software_name substring.
        Uses POST /qps/rest/2.0/get/am/hostasset/{id} with <ServiceRequest><id>HOST_ID</id></ServiceRequest>.
        """
        get_url = f"{self.base_url}/qps/rest/2.0/get/am/hostasset/{host_id}"
        req = ET.Element("ServiceRequest")
        ET.SubElement(req, "id").text = host_id
        xml_data = ET.tostring(req, encoding="utf-8", method="xml")

        resp = self.session.post(
            get_url,
            headers=self.qps_headers,
            auth=self.auth,
            data=xml_data,
            verify=self.cert_path
        )
        if resp.status_code == 403:
            raise Exception(f"Get HostAsset {host_id} returned 403 Forbidden.")
        try:
            resp.raise_for_status()
        except Exception as e:
            raise Exception(f"Get HostAsset HTTP error for ID={host_id}: {e}\nResponse:\n{resp.text}")

        # Parse XML
        try:
            root = ET.fromstring(resp.content)
        except ET.ParseError as e:
            raise Exception(f"Failed parsing get-hostasset XML for ID={host_id}: {e}\nContent:\n{resp.text}")

        # Check responseCode
        resp_code = root.findtext("responseCode")
        if resp_code != "SUCCESS":
            raise Exception(f"Get HostAsset responseCode={resp_code} for ID={host_id}. Response:\n{resp.text}")

        host_info = root.find(".//HostAsset")
        if host_info is None:
            return []

        records = []
        # Installed software entries under <HostAssetSoftwareList><HostAssetSoftware>
        for sw in host_info.findall(".//HostAssetSoftware"):
            name = (sw.findtext("name") or "").strip()
            version = (sw.findtext("version") or "").strip()
            # Match substring (case-insensitive)
            if software_name.lower() in name.lower():
                records.append({
                    "id": host_id,
                    "dnsHostName": dns,
                    "netbiosName": netbios,
                    "software": name,
                    "version": version
                })
        return records

    def run(self, software_name: str):
        """
        Main flow: login, search HostAssets, for each retrieve software details, write CSV, logout.
        """
        # 1. Login
        self.login()
        try:
            # 2. Search HostAsset entries
            host_elements = self.search_host_assets(software_name)
            if not host_elements:
                print(f"No HostAssets found for installedSoftware containing '{software_name}'.")
                return

            # 3. For each HostAsset element, extract id, dnsHostName, netbiosName if present in search response;
            #    else get from GET details. Sometimes search response includes basic fields:
            #    but for safety, retrieve dns/netbios from GET response too.
            all_records = []
            total = len(host_elements)
            print(f"[*] Retrieving software details for {total} HostAssets...")
            for idx, host_elem in enumerate(host_elements, start=1):
                host_id = host_elem.findtext("id")
                # Try to get dns/netbios from search response if present:
                dns = host_elem.findtext("dnsHostName", default="") or ""
                netbios = host_elem.findtext("netbiosName", default="") or ""
                try:
                    # If dns/netbios missing, GET will supply them
                    recs = self.get_software_for_host(host_id, dns, netbios, software_name)
                    if recs:
                        for rec in recs:
                            all_records.append(rec)
                        print(f"[{idx}/{total}] ✓ HostID={host_id}: {len(recs)} matching entries")
                    else:
                        print(f"[{idx}/{total}] ✗ HostID={host_id}: no matching software entries")
                except Exception as e:
                    print(f"[{idx}/{total}] ⚠️ Error processing HostID={host_id}: {e}")

            # 4. Write results to CSV
            if all_records:
                out_filename = f"hosts_with_{software_name.replace(' ', '_')}.csv"
                with open(out_filename, mode="w", newline="", encoding="utf-8") as f:
                    fieldnames = ["id", "dnsHostName", "netbiosName", "software", "version"]
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for row in all_records:
                        writer.writerow(row)
                print(f"[✓] CSV saved: {out_filename} (total entries: {len(all_records)})")
            else:
                print("No software entries matched in any HostAsset details.")
        finally:
            # 5. Logout
            self.logout()


def main():
    # === CONFIGURE with your credentials and certificate ===
    USERNAME = "your_qualys_username"
    PASSWORD = "your_qualys_password"
    CERT_PATH = "/path/to/your/corporate_cert.pem"  # Ensure this includes CA for SSL verification

    software_name = input("Enter software name to search (substring match): ").strip()
    if not software_name:
        print("Software name cannot be empty. Exiting.")
        sys.exit(1)

    searcher = QualysHostAssetSearcher(USERNAME, PASSWORD, CERT_PATH, page_size=100)
    searcher.run(software_name)


if __name__ == "__main__":
    main()
