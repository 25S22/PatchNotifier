import requests
import xml.etree.ElementTree as ET
import csv
import sys

# === CONFIGURATION ===
BASE_URL = "https://qualysapi.qg1.apps.qualys.com"  # Qualys API base for your region (QG1 for India)
USERNAME = "your_qualys_username"                   # <-- Replace with your Qualys username
PASSWORD = "your_qualys_password"                   # <-- Replace with your Qualys password
SSL_CERT_PATH = "/path/to/your/corporate_cert.pem"  # <-- Replace with path to your corporate CA bundle or cert
PAGE_SIZE = 100                                     # Number of records per page (Qualys default 100; max may be higher)

def login(session):
    """
    Perform FO session login, storing QualysSession cookie in the session.
    Raises Exception if login fails.
    """
    login_url = f"{BASE_URL}/api/2.0/fo/session/"
    data = {
        "action": "login",
        "username": USERNAME,
        "password": PASSWORD
    }
    headers = {"X-Requested-With": "PythonScript"}
    resp = session.post(login_url, data=data, headers=headers, verify=SSL_CERT_PATH)
    try:
        resp.raise_for_status()
    except Exception as e:
        raise Exception(f"Login HTTP error: {e}\nResponse content: {resp.text}")
    # Check QualysSession cookie presence
    if "QualysSession" not in session.cookies:
        raise Exception("Login failed: QualysSession cookie not set. Check credentials or SSL certificate.")
    print("[✓] Logged in to Qualys FO session.")

def logout(session):
    """
    Logout FO session.
    """
    logout_url = f"{BASE_URL}/api/2.0/fo/session/"
    data = {"action": "logout"}
    headers = {"X-Requested-With": "PythonScript"}
    try:
        resp = session.post(logout_url, data=data, headers=headers, verify=SSL_CERT_PATH)
        resp.raise_for_status()
    except Exception as e:
        print(f"[!] Warning: Logout HTTP error: {e}")
    else:
        print("[✓] Logged out from Qualys FO session.")

def search_host_assets(session, software_name):
    """
    Search Host Assets that have installedSoftware = software_name.
    Paginates until hasMoreRecords is false.
    Returns a list of host asset IDs (strings).
    """
    all_ids = []
    last_record_id = None

    print(f"[*] Beginning search for Host Assets with installed software: '{software_name}'")
    while True:
        # Build ServiceRequest XML
        root = ET.Element("ServiceRequest")
        filters = ET.SubElement(root, "filters")
        criteria = ET.SubElement(filters, "Criteria", field="installedSoftware", operator="EQUALS")
        criteria.text = software_name

        prefs = ET.SubElement(root, "preferences")
        ET.SubElement(prefs, "pageSize").text = str(PAGE_SIZE)
        if last_record_id:
            ET.SubElement(prefs, "lastRecordId").text = last_record_id

        xml_data = ET.tostring(root, encoding="utf-8")
        headers = {
            "X-Requested-With": "PythonScript",
            "Content-Type": "application/xml",
            "Accept": "application/xml"
        }
        search_url = f"{BASE_URL}/qps/rest/2.0/search/am/hostasset"
        resp = session.post(search_url, data=xml_data, headers=headers, verify=SSL_CERT_PATH)
        try:
            resp.raise_for_status()
        except Exception as e:
            raise Exception(f"Search Host Assets HTTP error: {e}\nResponse content: {resp.text}")

        # Parse XML response
        try:
            root_resp = ET.fromstring(resp.content)
        except ET.ParseError as e:
            raise Exception(f"Failed to parse search response XML: {e}\nContent: {resp.text}")

        # Extract host IDs
        ids = [elem.text for elem in root_resp.findall(".//HostAsset/id") if elem.text]
        if not ids:
            print("[→] No HostAsset IDs found in this page; ending search.")
            break

        all_ids.extend(ids)
        print(f"[→] Retrieved {len(ids)} HostAsset IDs in this page. Total so far: {len(all_ids)}")

        # Check pagination
        has_more = root_resp.findtext(".//hasMoreRecords") == "true"
        if has_more:
            last_record_id = ids[-1]
        else:
            break

    print(f"[✓] Completed search. Total HostAsset IDs found: {len(all_ids)}")
    return all_ids

def get_software_data_for_host(session, host_id, software_name):
    """
    For a given host asset ID, fetch its details and return a dict if the software_name is found,
    else return None.
    """
    get_url = f"{BASE_URL}/qps/rest/2.0/get/am/hostasset/{host_id}"
    headers = {
        "X-Requested-With": "PythonScript",
        "Content-Type": "application/xml",
        "Accept": "application/xml"
    }
    # Build request XML
    root = ET.Element("ServiceRequest")
    ET.SubElement(root, "id").text = host_id
    xml_data = ET.tostring(root, encoding="utf-8")

    resp = session.post(get_url, data=xml_data, headers=headers, verify=SSL_CERT_PATH)
    try:
        resp.raise_for_status()
    except Exception as e:
        raise Exception(f"Get HostAsset HTTP error (ID={host_id}): {e}\nResponse content: {resp.text}")

    # Parse XML
    try:
        root_resp = ET.fromstring(resp.content)
    except ET.ParseError as e:
        raise Exception(f"Failed to parse get-hostasset response XML for ID={host_id}: {e}\nContent: {resp.text}")

    host_elem = root_resp.find(".//HostAsset")
    if host_elem is None:
        # Unexpected: no HostAsset element
        return None

    dns = host_elem.findtext("dnsHostName", default="N/A")
    netbios = host_elem.findtext("netbiosName", default="N/A")

    # Look for matching software entry(s)
    for sw in host_elem.findall(".//HostAssetSoftware"):
        name = sw.findtext("name", "").strip()
        version = sw.findtext("version", "UNKNOWN").strip()
        if name.lower() == software_name.lower():
            # Found the software on this host
            return {
                "id": host_id,
                "dns": dns,
                "netbios": netbios,
                "software": name,
                "version": version
            }
    # Not found
    return None

def main():
    # Ask for software name
    software_name = input("Enter the software name to search for (exact match): ").strip()
    if not software_name:
        print("Software name cannot be empty. Exiting.")
        sys.exit(1)

    session = requests.Session()
    try:
        # Login
        login(session)

        # Search all host asset IDs with that software installed
        host_ids = search_host_assets(session, software_name)
        if not host_ids:
            print("No hosts found with that software. Exiting.")
            return

        # For each host ID, get software details
        results = []
        total = len(host_ids)
        print(f"[*] Fetching details for each of {total} hosts...")
        for idx, hid in enumerate(host_ids, start=1):
            try:
                rec = get_software_data_for_host(session, hid, software_name)
                if rec:
                    results.append(rec)
                    print(f"[{idx}/{total}] ✓ HostID={hid}, DNS='{rec['dns']}', Version='{rec['version']}'")
                else:
                    # This can happen if search returned the host but detail fetch didn't list it; unlikely but handle.
                    print(f"[{idx}/{total}] ✗ HostID={hid}: software not found in details")
            except Exception as e:
                print(f"[{idx}/{total}] ⚠️ Error processing HostID={hid}: {e}")

        # Write results to CSV
        out_filename = f"hosts_with_{software_name.replace(' ', '_')}.csv"
        with open(out_filename, mode="w", newline="", encoding="utf-8") as csvfile:
            fieldnames = ["id", "dns", "netbios", "software", "version"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in results:
                writer.writerow(row)

        print(f"[✓] Completed. Found {len(results)}/{total} hosts with software '{software_name}'.")
        print(f"[✓] CSV output saved to: {out_filename}")

    finally:
        # Logout in any case
        try:
            logout(session)
        except Exception as e:
            print(f"[!] Logout raised an exception: {e}")

if __name__ == "__main__":
    main()
