import requests
import xml.etree.ElementTree as ET
from requests.auth import HTTPBasicAuth
import csv
import sys
import logging

# === CONFIGURATION ===
USERNAME = "your_qualys_username"            # <-- replace
PASSWORD = "your_qualys_password"            # <-- replace
CERT_PATH = "/path/to/your/corporate_cert.pem"  # <-- replace: PEM bundle for SSL verification
BASE_URL = "https://qualysapi.qg1.apps.qualys.in"
PAGE_SIZE = 100      # adjust up to allowed max (e.g., 100 or 1000 if supported)
FILTER_OPERATOR = "CONTAINS"  # or "EQUALS" if you know the exact indexed software name
LOG_LEVEL = logging.INFO

# === LOGGER SETUP ===
logger = logging.getLogger("QualysHostAssetSearch")
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter("[%(levelname)s] %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(LOG_LEVEL)


class QualysHostAssetSearcher:
    """
    Searches Qualys Host Assets with installed software, returning only:
    HostAsset.id, HostAsset.dnsHostName, HostAsset.netbiosName,
    and nested HostAssetSoftwareList -> HostAssetSoftware name/version.
    """

    def __init__(self, username: str, password: str, cert_path: str, page_size: int = 100):
        self.base_url = BASE_URL.rstrip("/")
        self.session = requests.Session()
        # Basic Auth for QPS calls
        self.auth = HTTPBasicAuth(username, password)
        self.cert_path = cert_path
        self.page_size = page_size

        # FO session headers
        self.fo_headers = {"X-Requested-With": "Python script"}
        # QPS REST headers
        self.qps_headers = {
            "Content-Type": "application/xml",
            "Accept": "application/xml"
        }

    def login(self):
        """
        FO session login to Qualys: POST /api/2.0/fo/session/ with action=login.
        """
        login_url = f"{self.base_url}/api/2.0/fo/session/"
        data = {
            "action": "login",
            "username": self.auth.username,
            "password": self.auth.password
        }
        logger.info("Logging in to FO session...")
        resp = self.session.post(login_url, headers=self.fo_headers, data=data, verify=self.cert_path)
        try:
            resp.raise_for_status()
        except Exception as e:
            logger.error(f"Login HTTP error: {e}")
            logger.debug(f"Response status: {resp.status_code}, body:\n{resp.text}")
            raise

        if "QualysSession" not in self.session.cookies:
            logger.error("Login succeeded HTTP-wise but QualysSession cookie not found.")
            logger.debug(f"Cookies after login: {self.session.cookies.get_dict()}")
            raise Exception("Login failed: QualysSession cookie missing. Check credentials or SSL cert.")
        logger.info("Login successful.")

    def logout(self):
        """
        FO session logout.
        """
        logout_url = f"{self.base_url}/api/2.0/fo/session/"
        data = {"action": "logout"}
        logger.info("Logging out from FO session...")
        try:
            resp = self.session.post(logout_url, headers=self.fo_headers, data=data, verify=self.cert_path)
            resp.raise_for_status()
            logger.info("Logout successful.")
        except Exception as e:
            logger.warning(f"Logout HTTP error (ignored): {e}")

    def build_search_body(self, software_name: str, start_offset: int) -> bytes:
        """
        Build XML for search HostAsset with installedSoftware filter and fields:
        <ServiceRequest>
          <filters>
            <Criteria field="installedSoftware" operator="{FILTER_OPERATOR}">software_name</Criteria>
          </filters>
          <preferences>
            <startFromOffset>start_offset</startFromOffset>
            <limitResults>page_size</limitResults>
          </preferences>
          <fields>
            <HostAsset>
              <id/>
              <dnsHostName/>
              <netbiosName/>
              <HostAssetSoftwareList>
                <HostAssetSoftware>
                  <name/>
                  <version/>
                </HostAssetSoftware>
              </HostAssetSoftwareList>
            </HostAsset>
          </fields>
        </ServiceRequest>
        """
        root = ET.Element("ServiceRequest")
        # Filters
        filters = ET.SubElement(root, "filters")
        criteria = ET.SubElement(filters, "Criteria", field="installedSoftware", operator=FILTER_OPERATOR)
        criteria.text = software_name

        # Pagination
        prefs = ET.SubElement(root, "preferences")
        ET.SubElement(prefs, "startFromOffset").text = str(start_offset)
        ET.SubElement(prefs, "limitResults").text = str(self.page_size)

        # Fields selection
        fields = ET.SubElement(root, "fields")
        ha = ET.SubElement(fields, "HostAsset")
        ET.SubElement(ha, "id")
        ET.SubElement(ha, "dnsHostName")
        ET.SubElement(ha, "netbiosName")
        # Nested software list
        hasl = ET.SubElement(ha, "HostAssetSoftwareList")
        has = ET.SubElement(hasl, "HostAssetSoftware")
        ET.SubElement(has, "name")
        ET.SubElement(has, "version")

        xml_bytes = ET.tostring(root, encoding="utf-8", method="xml")
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug(f"Search request XML (offset={start_offset}):\n{xml_bytes.decode('utf-8')}")
        return xml_bytes

    def search(self, software_name: str):
        """
        Search HostAsset entries for installedSoftware matching software_name substring.
        Returns list of dicts: id, dnsHostName, netbiosName, software, version.
        """
        endpoint = f"{self.base_url}/qps/rest/2.0/search/am/hostasset"
        all_results = []
        offset = 1
        page = 1

        logger.info(f"Starting search for installedSoftware {FILTER_OPERATOR} '{software_name}'")
        while True:
            logger.info(f"Fetching page {page}, startFromOffset={offset}...")
            body = self.build_search_body(software_name, offset)
            resp = self.session.post(
                endpoint,
                headers=self.qps_headers,
                auth=self.auth,
                data=body,
                verify=self.cert_path
            )
            if resp.status_code == 403:
                logger.error("Search returned 403 Forbidden. Check Basic Auth or permissions.")
                logger.debug(f"Response body:\n{resp.text}")
                raise Exception("403 Forbidden on search")

            try:
                resp.raise_for_status()
            except Exception as e:
                logger.error(f"Search HTTP error: {e}")
                logger.debug(f"Response status: {resp.status_code}, body:\n{resp.text}")
                raise

            # Parse XML
            try:
                root = ET.fromstring(resp.content)
            except ET.ParseError as e:
                logger.error(f"Failed to parse search response XML: {e}")
                logger.debug(f"Response text:\n{resp.text}")
                raise

            # Check responseCode and total count
            resp_code = root.findtext("responseCode")
            total_count = root.findtext("count")
            logger.info(f"Search responseCode={resp_code}, reported count={total_count}")
            if resp_code != "SUCCESS":
                logger.error(f"Search responseCode not SUCCESS. Full response:\n{resp.text}")
                raise Exception(f"Search API returned responseCode={resp_code}")

            # Extract HostAsset entries
            host_assets = root.findall(".//HostAsset")
            count_page = len(host_assets)
            logger.info(f"Retrieved {count_page} HostAsset entries on page {page}")
            if count_page == 0:
                break

            # Parse each HostAsset entry
            for ha in host_assets:
                host_id = ha.findtext("id", default="")
                dns = ha.findtext("dnsHostName", default="")
                netbios = ha.findtext("netbiosName", default="")
                # For each nested HostAssetSoftware entry
                for sw in ha.findall(".//HostAssetSoftware"):
                    name = sw.findtext("name", default="")
                    version = sw.findtext("version", default="")
                    # Append result row
                    all_results.append({
                        "id": host_id,
                        "dnsHostName": dns,
                        "netbiosName": netbios,
                        "software": name,
                        "version": version
                    })

            # Pagination: hasMoreRecords?
            has_more = root.findtext(".//hasMoreRecords") == "true"
            logger.info(f"hasMoreRecords = {has_more}")
            if not has_more:
                break
            offset += self.page_size
            page += 1

        logger.info(f"Search completed. Total entries collected: {len(all_results)}")
        return all_results

    def run(self, software_name: str):
        """
        Main flow: login, search, write CSV, logout.
        """
        try:
            self.login()
        except Exception as e:
            logger.error(f"Login failed: {e}")
            return

        results = []
        try:
            results = self.search(software_name)
            if not results:
                logger.warning(f"No entries found for installedSoftware containing '{software_name}'.")
            else:
                out_filename = f"hostasset_{software_name.replace(' ', '_')}.csv"
                logger.info(f"Writing {len(results)} entries to CSV: {out_filename}")
                try:
                    with open(out_filename, mode="w", newline="", encoding="utf-8") as f:
                        fieldnames = ["id", "dnsHostName", "netbiosName", "software", "version"]
                        writer = csv.DictWriter(f, fieldnames=fieldnames)
                        writer.writeheader()
                        for row in results:
                            writer.writerow(row)
                    logger.info(f"CSV saved: {out_filename}")
                except Exception as e:
                    logger.error(f"Failed to write CSV: {e}")
        finally:
            self.logout()


def main():
    software_name = input("Enter software name to search (substring match): ").strip()
    if not software_name:
        logger.error("Software name cannot be empty. Exiting.")
        sys.exit(1)

    searcher = QualysHostAssetSearcher(USERNAME, PASSWORD, CERT_PATH, page_size=PAGE_SIZE)
    searcher.run(software_name)


if __name__ == "__main__":
    main()
